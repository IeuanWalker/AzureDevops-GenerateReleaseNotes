import * as Handlebars from 'handlebars';
import fs = require('fs');
import path = require('path');
import tl = require("azure-pipelines-task-lib/task");
import { TemplateData } from '../main';
import { printJson } from './JsonOutput';

export function registerHelpers(): void {
    // GroupBy helper
    Handlebars.registerHelper('groupBy', function(items: any[], field: string, options: any) {
        if (!Array.isArray(items) || !field) return '';
        const groups: Record<string, any[]> = {};
        items.forEach(item => {
            if (!item || typeof item !== 'object') return;
            const key = item[field] || 'Other';
            if (!groups[key]) groups[key] = [];
            groups[key].push(item);
        });
        let result = '';
        Object.keys(groups).forEach(key => {
            result += options.fn({ key, items: groups[key] });
        });
        return result;
    });
}

export function GenerateMarkdownReleaseNotes(
    data: TemplateData,
    outputFile: string,
    templateFile?: string
){

    // Get template
    let template: string;
    try {
        const hasValidTemplateFile = templateFile && 
            templateFile.trim() !== '' && 
            fs.existsSync(templateFile) && 
            fs.statSync(templateFile).isFile();
            
        if (hasValidTemplateFile) {
            template = fs.readFileSync(templateFile, 'utf8');
            console.log(`Using custom template: ${templateFile}`);
        } else {
            template = fs.readFileSync(
                path.join(__dirname, '..', '..', 'defaultTemplateMarkdown.hbs'),
                'utf-8'
            );
            console.log('Using default template');
        }
    } catch (error) {
        console.warn(`Error reading template file: ${error}. Using default template.`);
        template = fs.readFileSync(
            path.join(__dirname, '..', '..', 'defaultTemplateMarkdown.hbs'),
            'utf-8'
        );
    }


    template += `
    ---
    
    _Generated by [IeuanWalker.ReleaseNotesGenerator](https://marketplace.visualstudio.com/items?itemName=IeuanWalker.ReleaseNotesGenerator)_`


    // Generate release notes
    let releaseNotes: string;
    try {
        require('handlebars-helpers')({ Handlebars });
        const templateMarkdownFunc = Handlebars.compile(template);
        releaseNotes = templateMarkdownFunc(data);
    } catch (error) {
        tl.setResult(tl.TaskResult.Failed, `Failed to generate release notes from template: ${error}`);
        return;
    }    

    // Save release notes to file
    try {
        const outputDir = path.dirname(outputFile);
        if (!fs.existsSync(outputDir)) {
            fs.mkdirSync(outputDir, { recursive: true });
        }
        fs.writeFileSync(outputFile, releaseNotes, 'utf8');
        console.log(`Release notes written to: ${outputFile}`);
    } catch (error) {
        tl.setResult(tl.TaskResult.Failed, `Failed to write release notes to file: ${error}`);
        return;
    }

    tl.setResult(tl.TaskResult.Succeeded, `Markdown release notes generated successfully`);    
}

export function GenerateHtmlReleaseNotes(
    data: TemplateData,
    outputFile: string,
    templateFile?: string
){
    console.log('Starting HTML release notes generation...');
    
    // Convert PR descriptions from markdown to HTML
    const { marked } = require('marked');
    
    console.log(`Found ${data.pullRequests?.length || 0} pull requests`);
    console.log(`Found ${data.commits?.length || 0} commits`);
    
    // Convert descriptions in the pullRequests array
    if (Array.isArray(data.pullRequests) && data.pullRequests.length > 0) {
        console.log(`Processing ${data.pullRequests.length} pull requests`);
        data.pullRequests = data.pullRequests.map(pr => {
            console.log(`Checking PR ${pr.id}: has description = ${!!pr.description}, type = ${typeof pr.description}`);
            if (pr && pr.description != null && typeof pr.description === 'string' && pr.description.trim() !== '') {
                console.log(`Converting PR ${pr.id} description from markdown to HTML`);
                console.log(`Original (first 200 chars): ${pr.description.substring(0, 200)}`);
                try {
                    const converted = marked(pr.description);
                    console.log(`Converted (first 200 chars): ${converted.substring(0, 200)}`);
                    return {
                        ...pr,
                        description: converted
                    };
                } catch (error) {
                    console.warn(`Failed to convert markdown for PR: ${pr.id || 'unknown'}`, error);
                    return pr;
                }
            } else {
                console.log(`Skipping PR ${pr.id} - no valid description`);
            }
            return pr;
        });
    } else {
        console.log('No pull requests to process');
    }

    // Convert descriptions in commits.pullRequest objects
    if (Array.isArray(data.commits) && data.commits.length > 0) {
        console.log(`Processing ${data.commits.length} commits`);
        data.commits = data.commits.map(commit => {
            if (commit && commit.pullRequest) {
                console.log(`Checking commit PR ${commit.pullRequest.id}: has description = ${!!commit.pullRequest.description}, type = ${typeof commit.pullRequest.description}`);
                if (commit.pullRequest.description != null && 
                    typeof commit.pullRequest.description === 'string' && 
                    commit.pullRequest.description.trim() !== '') {
                    console.log(`Converting commit PR ${commit.pullRequest.id} description from markdown to HTML`);
                    console.log(`Original (first 200 chars): ${commit.pullRequest.description.substring(0, 200)}`);
                    try {
                        const converted = marked(commit.pullRequest.description);
                        console.log(`Converted (first 200 chars): ${converted.substring(0, 200)}`);
                        return {
                            ...commit,
                            pullRequest: {
                                ...commit.pullRequest,
                                description: converted
                            }
                        };
                    } catch (error) {
                        console.warn(`Failed to convert markdown for commit PR: ${commit.pullRequest.id || 'unknown'}`, error);
                        return commit;
                    }
                } else {
                    console.log(`Skipping commit PR ${commit.pullRequest.id} - no valid description`);
                }
            }
            return commit;
        });
    } else {
        console.log('No commits to process');
    }


    console.log('Markdown conversion complete, proceeding with template generation...');

    printJson(data);

    // Get template
    let template: string;
    try {
        const hasValidTemplateFile = templateFile && 
            templateFile.trim() !== '' && 
            fs.existsSync(templateFile) && 
            fs.statSync(templateFile).isFile();
            
        if (hasValidTemplateFile) {
            template = fs.readFileSync(templateFile, 'utf8');
            console.log(`Using custom template: ${templateFile}`);
        } else {
            template = fs.readFileSync(
                path.join(__dirname, '..', '..', 'defaultTemplateHtml.hbs'),
                'utf-8'
            );
            console.log('Using default template');
        }
    } catch (error) {
        console.warn(`Error reading template file: ${error}. Using default template.`);
        template = fs.readFileSync(
            path.join(__dirname, '..', '..', 'defaultTemplateHtml.hbs'),
            'utf-8'
        );
    }

    const footerHtml = `
    <footer>
        <p>
            Generated by <a href="https://marketplace.visualstudio.com/items?itemName=IeuanWalker.ReleaseNotesGenerator">IeuanWalker.ReleaseNotesGenerator</a>
        </p>
    </footer>
    `;
    if (template.includes('</body>')) {
        template = template.replace('</body>', `${footerHtml}\n</body>`);
    } else {
        template += footerHtml;
    }

    // Generate release notes
    let releaseNotes: string;
    try {
        const handlebarsHelpers = require('handlebars-helpers');
        handlebarsHelpers({ Handlebars });
        const templateHtmlFunc = Handlebars.compile(template);
        releaseNotes = templateHtmlFunc(data);
    } catch (error) {
        tl.setResult(tl.TaskResult.Failed, `Failed to generate release notes from template: ${error}`);
        return;
    }    

    // Save release notes to file
    try {
        const outputDir = path.dirname(outputFile);
        if (!fs.existsSync(outputDir)) {
            fs.mkdirSync(outputDir, { recursive: true });
        }
        fs.writeFileSync(outputFile, releaseNotes, 'utf8');
        console.log(`Release notes written to: ${outputFile}`);
    } catch (error) {
        tl.setResult(tl.TaskResult.Failed, `Failed to write release notes to file: ${error}`);
        return;
    }

    tl.setResult(tl.TaskResult.Succeeded, `HTML release notes generated successfully`);    
}