"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GenerateHtmlReleaseNotes = exports.GenerateMarkdownReleaseNotes = exports.registerHelpers = void 0;
const Handlebars = __importStar(require("handlebars"));
const fs = require("fs");
const path = require("path");
const tl = require("azure-pipelines-task-lib/task");
const JsonOutput_1 = require("./JsonOutput");
function registerHelpers() {
    // GroupBy helper
    Handlebars.registerHelper('groupBy', function (items, field, options) {
        if (!Array.isArray(items) || !field)
            return '';
        const groups = {};
        items.forEach(item => {
            if (!item || typeof item !== 'object')
                return;
            const key = item[field] || 'Other';
            if (!groups[key])
                groups[key] = [];
            groups[key].push(item);
        });
        let result = '';
        Object.keys(groups).forEach(key => {
            result += options.fn({ key, items: groups[key] });
        });
        return result;
    });
}
exports.registerHelpers = registerHelpers;
function GenerateMarkdownReleaseNotes(data, outputFile, templateFile) {
    // Get template
    let template;
    try {
        const hasValidTemplateFile = templateFile &&
            templateFile.trim() !== '' &&
            fs.existsSync(templateFile) &&
            fs.statSync(templateFile).isFile();
        if (hasValidTemplateFile) {
            template = fs.readFileSync(templateFile, 'utf8');
            console.log(`Using custom template: ${templateFile}`);
        }
        else {
            template = fs.readFileSync(path.join(__dirname, '..', '..', 'defaultTemplateMarkdown.hbs'), 'utf-8');
            console.log('Using default template');
        }
    }
    catch (error) {
        console.warn(`Error reading template file: ${error}. Using default template.`);
        template = fs.readFileSync(path.join(__dirname, '..', '..', 'defaultTemplateMarkdown.hbs'), 'utf-8');
    }
    template += `
    ---
    
    _Generated by [IeuanWalker.ReleaseNotesGenerator](https://marketplace.visualstudio.com/items?itemName=IeuanWalker.ReleaseNotesGenerator)_`;
    // Generate release notes
    let releaseNotes;
    try {
        require('handlebars-helpers')({ Handlebars });
        const templateMarkdownFunc = Handlebars.compile(template);
        releaseNotes = templateMarkdownFunc(data);
    }
    catch (error) {
        tl.setResult(tl.TaskResult.Failed, `Failed to generate release notes from template: ${error}`);
        return;
    }
    // Save release notes to file
    try {
        const outputDir = path.dirname(outputFile);
        if (!fs.existsSync(outputDir)) {
            fs.mkdirSync(outputDir, { recursive: true });
        }
        fs.writeFileSync(outputFile, releaseNotes, 'utf8');
        console.log(`Release notes written to: ${outputFile}`);
    }
    catch (error) {
        tl.setResult(tl.TaskResult.Failed, `Failed to write release notes to file: ${error}`);
        return;
    }
    tl.setResult(tl.TaskResult.Succeeded, `Markdown release notes generated successfully`);
}
exports.GenerateMarkdownReleaseNotes = GenerateMarkdownReleaseNotes;
function GenerateHtmlReleaseNotes(data, outputFile, templateFile) {
    var _a, _b;
    console.log('Starting HTML release notes generation...');
    // Convert PR descriptions from markdown to HTML
    const { marked } = require('marked');
    console.log(`Found ${((_a = data.pullRequests) === null || _a === void 0 ? void 0 : _a.length) || 0} pull requests`);
    console.log(`Found ${((_b = data.commits) === null || _b === void 0 ? void 0 : _b.length) || 0} commits`);
    // Convert descriptions in the pullRequests array
    if (Array.isArray(data.pullRequests) && data.pullRequests.length > 0) {
        console.log(`Processing ${data.pullRequests.length} pull requests`);
        data.pullRequests = data.pullRequests.map(pr => {
            console.log(`Checking PR ${pr.id}: has description = ${!!pr.description}, type = ${typeof pr.description}`);
            if (pr && pr.description != null && typeof pr.description === 'string' && pr.description.trim() !== '') {
                console.log(`Converting PR ${pr.id} description from markdown to HTML`);
                console.log(`Original (first 200 chars): ${pr.description.substring(0, 200)}`);
                try {
                    const converted = marked(pr.description);
                    console.log(`Converted (first 200 chars): ${converted.substring(0, 200)}`);
                    return Object.assign(Object.assign({}, pr), { description: converted });
                }
                catch (error) {
                    console.warn(`Failed to convert markdown for PR: ${pr.id || 'unknown'}`, error);
                    return pr;
                }
            }
            else {
                console.log(`Skipping PR ${pr.id} - no valid description`);
            }
            return pr;
        });
    }
    else {
        console.log('No pull requests to process');
    }
    // Convert descriptions in commits.pullRequest objects
    if (Array.isArray(data.commits) && data.commits.length > 0) {
        console.log(`Processing ${data.commits.length} commits`);
        data.commits = data.commits.map(commit => {
            if (commit && commit.pullRequest) {
                console.log(`Checking commit PR ${commit.pullRequest.id}: has description = ${!!commit.pullRequest.description}, type = ${typeof commit.pullRequest.description}`);
                if (commit.pullRequest.description != null &&
                    typeof commit.pullRequest.description === 'string' &&
                    commit.pullRequest.description.trim() !== '') {
                    console.log(`Converting commit PR ${commit.pullRequest.id} description from markdown to HTML`);
                    console.log(`Original (first 200 chars): ${commit.pullRequest.description.substring(0, 200)}`);
                    try {
                        const converted = marked(commit.pullRequest.description);
                        console.log(`Converted (first 200 chars): ${converted.substring(0, 200)}`);
                        return Object.assign(Object.assign({}, commit), { pullRequest: Object.assign(Object.assign({}, commit.pullRequest), { description: converted }) });
                    }
                    catch (error) {
                        console.warn(`Failed to convert markdown for commit PR: ${commit.pullRequest.id || 'unknown'}`, error);
                        return commit;
                    }
                }
                else {
                    console.log(`Skipping commit PR ${commit.pullRequest.id} - no valid description`);
                }
            }
            return commit;
        });
    }
    else {
        console.log('No commits to process');
    }
    console.log('Markdown conversion complete, proceeding with template generation...');
    (0, JsonOutput_1.printJson)(data);
    // Get template
    let template;
    try {
        const hasValidTemplateFile = templateFile &&
            templateFile.trim() !== '' &&
            fs.existsSync(templateFile) &&
            fs.statSync(templateFile).isFile();
        if (hasValidTemplateFile) {
            template = fs.readFileSync(templateFile, 'utf8');
            console.log(`Using custom template: ${templateFile}`);
        }
        else {
            template = fs.readFileSync(path.join(__dirname, '..', '..', 'defaultTemplateHtml.hbs'), 'utf-8');
            console.log('Using default template');
        }
    }
    catch (error) {
        console.warn(`Error reading template file: ${error}. Using default template.`);
        template = fs.readFileSync(path.join(__dirname, '..', '..', 'defaultTemplateHtml.hbs'), 'utf-8');
    }
    const footerHtml = `
    <footer>
        <p>
            Generated by <a href="https://marketplace.visualstudio.com/items?itemName=IeuanWalker.ReleaseNotesGenerator">IeuanWalker.ReleaseNotesGenerator</a>
        </p>
    </footer>
    `;
    if (template.includes('</body>')) {
        template = template.replace('</body>', `${footerHtml}\n</body>`);
    }
    else {
        template += footerHtml;
    }
    // Generate release notes
    let releaseNotes;
    try {
        const handlebarsHelpers = require('handlebars-helpers');
        handlebarsHelpers({ Handlebars });
        const templateHtmlFunc = Handlebars.compile(template);
        releaseNotes = templateHtmlFunc(data);
    }
    catch (error) {
        tl.setResult(tl.TaskResult.Failed, `Failed to generate release notes from template: ${error}`);
        return;
    }
    // Save release notes to file
    try {
        const outputDir = path.dirname(outputFile);
        if (!fs.existsSync(outputDir)) {
            fs.mkdirSync(outputDir, { recursive: true });
        }
        fs.writeFileSync(outputFile, releaseNotes, 'utf8');
        console.log(`Release notes written to: ${outputFile}`);
    }
    catch (error) {
        tl.setResult(tl.TaskResult.Failed, `Failed to write release notes to file: ${error}`);
        return;
    }
    tl.setResult(tl.TaskResult.Succeeded, `HTML release notes generated successfully`);
}
exports.GenerateHtmlReleaseNotes = GenerateHtmlReleaseNotes;
